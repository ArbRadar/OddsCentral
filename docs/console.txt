â›” VISUAL SCRAPING DISABLED - Content script should not be running active scraping
Context
https://oddsjam.com/mlb/screen/moneyline
Stack Trace
content.js:2952 (checkAndSendUpdates)
content.js:3204 (anonymous function)
...
2412
2413
2414
2415
2416
2417
2418
2419
2420
2421
2422
2423
2424
2425
2426
2427
2428
2429
2430
2431
2432
2433
2434
2435
2436
2437
2438
2439
2440
2441
2442
2443
2444
2445
2446
2447
2448
2449
2450
2451
2452
2453
2454
2455
2456
2457
2458
2459
2460
2461
2462
2463
2464
2465
2466
2467
2468
2469
2470
2471
2472
2473
2474
2475
2476
2477
2478
2479
2480
2481
2482
2483
2484
2485
2486
2487
2488
2489
2490
2491
2492
2493
2494
2495
2496
2497
2498
2499
2500
2501
2502
2503
2504
2505
2506
2507
2508
2509
2510
2511
2512
2513
2514
2515
2516
2517
2518
2519
2520
2521
2522
2523
2524
2525
2526
2527
2528
2529
2530
2531
2532
2533
2534
2535
2536
2537
2538
2539
2540
2541
2542
2543
2544
2545
2546
2547
2548
2549
2550
2551
2552
2553
2554
2555
2556
2557
2558
2559
2560
2561
2562
2563
2564
2565
2566
2567
2568
2569
2570
2571
2572
2573
2574
2575
2576
2577
2578
2579
2580
2581
2582
2583
2584
2585
2586
2587
2588
2589
2590
2591
2592
2593
2594
2595
2596
2597
2598
2599
2600
2601
2602
2603
2604
2605
2606
2607
2608
2609
2610
2611
2612
2613
2614
2615
2616
2617
2618
2619
2620
2621
2622
2623
2624
2625
2626
2627
2628
2629
2630
2631
2632
2633
2634
2635
2636
2637
2638
2639
2640
2641
2642
2643
2644
2645
2646
2647
2648
2649
2650
2651
2652
2653
2654
2655
2656
2657
2658
2659
2660
2661
2662
2663
2664
2665
2666
2667
2668
2669
2670
2671
2672
2673
2674
2675
2676
2677
2678
2679
2680
2681
2682
2683
2684
2685
2686
2687
2688
2689
2690
2691
2692
2693
2694
2695
2696
2697
2698
2699
2700
2701
2702
2703
2704
2705
2706
2707
2708
2709
2710
2711
2712
2713
2714
2715
2716
2717
2718
2719
2720
2721
2722
2723
2724
2725
2726
2727
2728
2729
2730
2731
2732
2733
2734
2735
2736
2737
2738
2739
2740
2741
2742
2743
2744
2745
2746
2747
2748
2749
2750
2751
2752
2753
2754
2755
2756
2757
2758
2759
2760
2761
2762
2763
2764
2765
2766
2767
2768
2769
2770
2771
2772
2773
2774
2775
2776
2777
2778
2779
2780
2781
2782
2783
2784
2785
2786
2787
2788
2789
2790
2791
2792
2793
2794
2795
2796
2797
2798
2799
2800
2801
2802
2803
2804
2805
2806
2807
2808
2809
2810
2811
2812
2813
2814
2815
2816
2817
2818
2819
2820
2821
2822
2823
2824
2825
2826
2827
2828
2829
2830
2831
2832
2833
2834
2835
2836
2837
2838
2839
2840
2841
2842
2843
2844
2845
2846
2847
2848
2849
2850
2851
2852
2853
2854
2855
2856
2857
2858
2859
2860
2861
2862
2863
2864
2865
2866
2867
2868
2869
2870
2871
2872
2873
2874
2875
2876
2877
2878
2879
2880
2881
2882
2883
2884
2885
2886
2887
2888
2889
2890
2891
2892
2893
2894
2895
2896
2897
2898
2899
2900
2901
2902
2903
2904
2905
2906
2907
2908
2909
2910
2911
2912
2913
2914
2915
2916
2917
2918
2919
2920
2921
2922
2923
2924
2925
2926
2927
2928
2929
2930
2931
2932
2933
2934
2935
2936
2937
2938
2939
2940
2941
2942
2943
2944
2945
2946
2947
2948
2949
2950
2951
2952
2953
2954
2955
2956
2957
2958
2959
2960
2961
2962
2963
2964
2965
2966
2967
2968
2969
2970
2971
2972
2973
2974
2975
2976
2977
2978
2979
2980
2981
2982
2983
2984
2985
2986
2987
2988
2989
2990
2991
2992
2993
2994
2995
2996
2997
2998
2999
3000
3001
3002
3003
3004
3005
3006
3007
3008
3009
3010
3011
3012
3013
3014
3015
3016
3017
3018
3019
3020
3021
3022
3023
3024
3025
3026
3027
3028
3029
3030
3031
3032
3033
3034
3035
3036
3037
3038
3039
3040
3041
3042
3043
3044
3045
3046
3047
3048
3049
3050
3051
3052
3053
3054
3055
3056
3057
3058
3059
3060
3061
3062
3063
3064
3065
3066
3067
3068
3069
3070
3071
3072
3073
3074
3075
3076
3077
3078
3079
3080
3081
3082
3083
3084
3085
3086
3087
3088
3089
3090
3091
3092
3093
3094
3095
3096
3097
3098
3099
3100
3101
3102
3103
3104
3105
3106
3107
3108
3109
3110
3111
3112
3113
3114
3115
3116
3117
3118
3119
3120
3121
3122
3123
3124
3125
3126
3127
3128
3129
3130
3131
3132
3133
3134
3135
3136
3137
3138
3139
3140
3141
3142
3143
3144
3145
3146
3147
3148
3149
3150
3151
3152
3153
3154
3155
3156
3157
3158
3159
3160
3161
3162
3163
3164
3165
3166
3167
3168
3169
3170
3171
3172
3173
3174
3175
3176
3177
3178
3179
3180
3181
3182
3183
3184
3185
3186
3187
3188
3189
3190
3191
3192
3193
3194
3195
3196
3197
3198
3199
3200
3201
3202
3203
3204
3205
3206
3207
3208
3209
3210
3211
3212
3213
3214
3215
3216
3217
3218
3219
3220
3221
3222
3223
3224
3225
3226
3227
3228
3229
3230
3231
3232
3233
3234
3235
3236
3237
3238
3239
3240
3241
3242
3243
3244
3245
3246
3247
3248
3249
3250
3251
3252
3253
3254
3255
3256
3257
3258
3259
3260
3261
3262
3263
3264
3265
3266
3267
3268
3269
3270
3271
3272
3273
3274
3275
3276
3277
3278
3279
3280
3281
3282
3283
3284
3285
3286
3287
3288
3289
3290
3291
3292
3293
3294
3295
3296
3297
3298
3299
3300
3301
3302
3303
3304
3305
3306
3307
3308
3309
3310
3311
3312
3313
3314
3315
3316
3317
3318
3319
3320
3321
3322
3323
3324
3325
3326
3327
3328
3329
3330
3331
3332
3333
3334
3335
3336
3337
3338
3339
3340
3341
3342
3343
3344
3345
3346
3347
3348
3349
3350
3351
3352
3353
3354
3355
3356
3357
3358
3359
3360
3361
3362
3363
3364
3365
3366
3367
3368
3369
3370
3371
3372
3373
3374
3375
3376
3377
3378
3379
3380
3381
3382
3383
3384
3385
3386
3387
3388
3389
3390
3391
3392
3393
3394
3395
3396
3397
3398
3399
3400
3401
3402
3403
3404
3405
3406
3407
3408
3409
3410
<2411 lines not shown>
async function triggerLazyLoadingInCurrentSection() {
  console.log('ðŸ”„ Triggering lazy loading for current section...');

  // Trigger intersection observers by creating fake scroll events
  const scrollEvent = new Event('scroll', { bubbles: true });
  const resizeEvent = new Event('resize', { bubbles: true });

  document.dispatchEvent(scrollEvent);
  window.dispatchEvent(scrollEvent);
  window.dispatchEvent(resizeEvent);

  // Trigger mouse movement to activate hover-based loading
  const mouseEvent = new MouseEvent('mousemove', {
    bubbles: true,
    cancelable: true,
    clientX: window.innerWidth / 2,
    clientY: window.innerHeight / 2
  });
  document.dispatchEvent(mouseEvent);

  // Small delay for lazy loading to trigger
  await new Promise(resolve => setTimeout(resolve, 500));
  console.log('ðŸ”„ Lazy loading triggers sent');
}

// Perform comprehensive scrolling to load all content
async function performAggressiveScrolling() {
  console.log('ðŸš€ Performing aggressive scrolling...');

  const SELECTORS = getSelectors();
  const grid = document.querySelector(SELECTORS.grid.root);
  if (!grid) return;

  // Find all scrollable containers
  const scrollContainers = [
    grid.querySelector('.ag-body-viewport'),
    grid.querySelector('.ag-center-cols-viewport'),
    grid.querySelector('.ag-center-cols-container'),
    grid,
    document.documentElement,
    document.body
  ].filter(Boolean);

  console.log(`ðŸš€ Found ${scrollContainers.length} scrollable containers`);

  for (const container of scrollContainers) {
    await scrollContainerComprehensively(container);
  }

  // Additional aggressive techniques
  await forceTableCellsIntoView();
}

// Scroll a single container in all directions comprehensively
async function scrollContainerComprehensively(container) {
  const maxScrollLeft = container.scrollWidth - container.clientWidth;
  const maxScrollTop = container.scrollHeight - container.clientHeight;

  if (maxScrollLeft <= 0 && maxScrollTop <= 0) return;

  console.log(`ðŸš€ Scrolling container: ${maxScrollLeft}px horizontal, ${maxScrollTop}px vertical`);

  const originalScrollLeft = container.scrollLeft;
  const originalScrollTop = container.scrollTop;

  // Horizontal scrolling strategy - multiple passes
  const horizontalSteps = Math.min(20, Math.max(5, Math.ceil(maxScrollLeft / 200)));
  for (let i = 0; i <= horizontalSteps; i++) {
    const scrollLeft = (i / horizontalSteps) * maxScrollLeft;
    container.scrollLeft = scrollLeft;
    await new Promise(resolve => setTimeout(resolve, 50));

    // At each horizontal position, do vertical scrolling
    const verticalSteps = Math.min(10, Math.max(3, Math.ceil(maxScrollTop / 300)));
    for (let j = 0; j <= verticalSteps; j++) {
      const scrollTop = (j / verticalSteps) * maxScrollTop;
      container.scrollTop = scrollTop;
      await new Promise(resolve => setTimeout(resolve, 30));
    }
  }

  // Return to original position
  container.scrollLeft = originalScrollLeft;
  container.scrollTop = originalScrollTop;
  await new Promise(resolve => setTimeout(resolve, 100));
}

// Force individual table cells into view to trigger rendering
async function forceTableCellsIntoView() {
  console.log('ðŸš€ Forcing table cells into view...');

  const SELECTORS = getSelectors();
  const grid = document.querySelector(SELECTORS.grid.root);
  if (!grid) return;

  // Find all cells with col-id attributes (these are sportsbook columns)
  const allCells = grid.querySelectorAll('[col-id]');
  console.log(`ðŸš€ Found ${allCells.length} cells to check`);

  // Process in batches to avoid overwhelming the browser
  const batchSize = 50;
  for (let i = 0; i < allCells.length; i += batchSize) {
    const batch = Array.from(allCells).slice(i, i + batchSize);

    for (const cell of batch) {
      try {
        // Force the cell into view
        cell.scrollIntoView({ behavior: 'auto', block: 'nearest', inline: 'nearest' });

        // Trigger any observers or lazy loading
        const rect = cell.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
          // Simulate interaction to trigger updates
          cell.dispatchEvent(new Event('mouseenter', { bubbles: true }));
          cell.dispatchEvent(new Event('focus', { bubbles: true }));
        }
      } catch (e) {
        // Ignore errors for individual cells
      }
    }

    // Small delay between batches
    await new Promise(resolve => setTimeout(resolve, 20));
  }
}

// Trigger lazy loading mechanisms
async function triggerLazyLoading() {
  console.log('ðŸš€ Triggering lazy loading mechanisms...');

  // Create intersection observer events for all elements
  const allElements = document.querySelectorAll('*');
  const observedElements = Array.from(allElements).filter(el => {
    return el.offsetParent !== null || // visible elements
           el.tagName === 'TR' ||       // table rows
           el.hasAttribute('col-id') || // grid columns
           el.hasAttribute('row-id') || // grid rows
           el.getAttribute('class')?.includes('ag-'); // AG Grid elements
  });

  console.log(`ðŸš€ Triggering intersection events for ${observedElements.length} elements`);

  // Batch process to avoid performance issues
  const batchSize = 100;
  for (let i = 0; i < observedElements.length; i += batchSize) {
    const batch = observedElements.slice(i, i + batchSize);

    batch.forEach(el => {
      try {
        // Simulate intersection observer entry
        const rect = el.getBoundingClientRect();
        const intersectionEvent = new CustomEvent('intersection', {
          detail: {
            isIntersecting: true,
            intersectionRatio: 1,
            boundingClientRect: rect,
            target: el
          }
        });
        el.dispatchEvent(intersectionEvent);

        // Also trigger scroll events that might load content
        el.dispatchEvent(new Event('scroll', { bubbles: true }));

      } catch (e) {
        // Ignore individual element errors
      }
    });

    await new Promise(resolve => setTimeout(resolve, 10));
  }

  // Wait for any async loading to complete
  await new Promise(resolve => setTimeout(resolve, 500));
}

// Multi-pass scraping to catch newly loaded content
async function performMultiPassScraping() {
  console.log('ðŸš€ Starting multi-pass scraping strategy...');

  let bestData = { games: [] };
  const maxPasses = 3;

  for (let pass = 1; pass <= maxPasses; pass++) {
    console.log(`ðŸš€ Scraping pass ${pass}/${maxPasses}...`);

    // Quick additional scrolling before each pass
    if (pass > 1) {
      await quickRefreshScroll();
    }

    const data = await scrapeData();

    if (data && data.games.length > 0) {
      const totalOdds = data.games.reduce((sum, game) => sum + Object.keys(game.odds || {}).length, 0);
      const previousBestOdds = bestData.games.reduce((sum, game) => sum + Object.keys(game.odds || {}).length, 0);

      console.log(`ðŸš€ Pass ${pass}: Found ${data.games.length} games, ${totalOdds} total odds`);

      // Keep the data with the most odds
      if (totalOdds > previousBestOdds) {
        bestData = data;
        console.log(`ðŸš€ Pass ${pass}: New best data! (${totalOdds} odds vs ${previousBestOdds})`);
      }
    }

    // Small delay between passes
    if (pass < maxPasses) {
      await new Promise(resolve => setTimeout(resolve, 200));
    }
  }

  console.log(`ðŸš€ Multi-pass complete: Final result has ${bestData.games.length} games`);
  return bestData;
}

// Force AG Grid virtual rows to render by manipulating the grid API
async function forceAGGridVirtualRowsToRender() {
  console.log('ðŸš€ Forcing AG Grid virtual rows to render...');

  const SELECTORS = getSelectors();
  const grid = document.querySelector(SELECTORS.grid.root);
  if (!grid) return;

  try {
    // Try to access AG Grid API from the DOM element
    const gridApi = grid.gridApi || grid.__agGridApi || grid._gridApi;

    if (gridApi) {
      console.log('ðŸš€ Found AG Grid API, forcing row model refresh...');

      // Force refresh of the row model
      if (gridApi.refreshInfiniteCache) {
        gridApi.refreshInfiniteCache();
      }
      if (gridApi.purgeInfiniteCache) {
        gridApi.purgeInfiniteCache();
      }
      if (gridApi.onRowDataChanged) {
        gridApi.onRowDataChanged();
      }
      if (gridApi.refreshView) {
        gridApi.refreshView();
      }
      if (gridApi.redrawRows) {
        gridApi.redrawRows();
      }
      if (gridApi.ensureIndexVisible) {
        // Try to ensure all rows are visible by scrolling through row indices
        const rowCount = gridApi.getDisplayedRowCount();
        if (rowCount > 0) {
          console.log(`ðŸš€ AG Grid has ${rowCount} rows, ensuring all are rendered...`);

          // Force render chunks of rows
          const chunkSize = 20;
          for (let i = 0; i < rowCount; i += chunkSize) {
            gridApi.ensureIndexVisible(i, 'top');
            await new Promise(resolve => setTimeout(resolve, 50));
          }

          // Ensure last row is visible
          gridApi.ensureIndexVisible(rowCount - 1, 'bottom');
          await new Promise(resolve => setTimeout(resolve, 100));

          // Go back to top
          gridApi.ensureIndexVisible(0, 'top');
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }

      await new Promise(resolve => setTimeout(resolve, 500));

    } else {
      console.log('ðŸš€ No AG Grid API found, using alternative virtual scroll forcing...');
      await forceVirtualScrollWithoutAPI();
    }

  } catch (error) {
    console.log('ðŸš€ Error accessing AG Grid API, falling back to manual methods:', error);
    await forceVirtualScrollWithoutAPI();
  }
}

// Alternative method when AG Grid API is not available
async function forceVirtualScrollWithoutAPI() {
  const SELECTORS = getSelectors();
  const grid = document.querySelector(SELECTORS.grid.root);
  if (!grid) return;

  // Find the virtual scrolling viewport
  const viewport = grid.querySelector('.ag-body-viewport') || grid.querySelector('.ag-center-cols-viewport');
  if (!viewport) return;

  console.log('ðŸš€ Using manual virtual scroll forcing...');

  const originalScrollTop = viewport.scrollTop;
  const maxScrollTop = viewport.scrollHeight - viewport.clientHeight;

  if (maxScrollTop > 0) {
    console.log(`ðŸš€ Scrolling through ${maxScrollTop}px of virtual content...`);

    // Scroll through the entire virtual content in steps
    const steps = Math.min(50, Math.max(10, Math.ceil(maxScrollTop / 100)));

    for (let i = 0; i <= steps; i++) {
      const scrollTop = (i / steps) * maxScrollTop;
      viewport.scrollTop = scrollTop;

      // Wait for virtual rows to render
      await new Promise(resolve => setTimeout(resolve, 30));
    }

    // Return to original position
    viewport.scrollTop = originalScrollTop;
    await new Promise(resolve => setTimeout(resolve, 200));
  }
}

// Quick refresh scroll to load any new content
async function quickRefreshScroll() {
  const SELECTORS = getSelectors();
  const grid = document.querySelector(SELECTORS.grid.root);
  if (!grid) return;

  const viewport = grid.querySelector('.ag-body-viewport') || grid.querySelector('.ag-center-cols-viewport');
  if (!viewport) return;

  // Quick horizontal scroll to refresh columns
  const originalScrollLeft = viewport.scrollLeft;
  const maxScrollLeft = viewport.scrollWidth - viewport.clientWidth;

  if (maxScrollLeft > 0) {
    viewport.scrollLeft = Math.min(maxScrollLeft, originalScrollLeft + 100);
    await new Promise(resolve => setTimeout(resolve, 50));
    viewport.scrollLeft = Math.max(0, originalScrollLeft - 100);
    await new Promise(resolve => setTimeout(resolve, 50));
    viewport.scrollLeft = originalScrollLeft;
  }
}

// Ensure all columns are loaded - only scroll once on initial load
async function ensureAllColumnsLoaded() {
  // Only do this once per page load to avoid detection
  if (hasLoadedAllColumns) {
    console.log('ensureAllColumnsLoaded: Already loaded all columns once');
    return;
  }

  const SELECTORS = getSelectors();
  const grid = document.querySelector(SELECTORS.grid.root);

  if (!grid || !currentLayout.features.multiContainer) {
    console.log('ensureAllColumnsLoaded: Grid not found or not multi-container layout');
    return;
  }

  // First, try to get column info from AG Grid API
  const gridApi = getAGGridApi();
  if (gridApi && gridApi.getAllColumns) {
    try {
      const allColumns = gridApi.getAllColumns();
      console.log(`Found ${allColumns.length} columns via AG Grid API`);
      const columnIds = allColumns.map(col => col.getColId());
      console.log('All column IDs from API:', columnIds);
      hasLoadedAllColumns = true;
      return;
    } catch (e) {
      console.log('Failed to get columns from API:', e);
    }
  }

  // Find the center viewport that contains scrollable columns
  const centerViewport = grid.querySelector('.ag-body-viewport, .ag-center-cols-viewport');
  if (!centerViewport) {
    console.log('ensureAllColumnsLoaded: No scrollable viewport found');
    return;
  }

  console.log('ensureAllColumnsLoaded: Performing one-time column discovery...');

  // Get scroll dimensions
  const scrollWidth = centerViewport.scrollWidth;
  const clientWidth = centerViewport.clientWidth;
  const originalScrollLeft = centerViewport.scrollLeft;

  console.log(`ensureAllColumnsLoaded: Viewport ${clientWidth}px wide, content ${scrollWidth}px wide`);

  if (scrollWidth <= clientWidth) {
    console.log('ensureAllColumnsLoaded: All content already visible');
    hasLoadedAllColumns = true;
    return;
  }

  // Perform a single smooth scroll to discover columns
  console.log('ensureAllColumnsLoaded: Performing one-time scroll to discover columns...');

  // Scroll smoothly to the end
  centerViewport.scrollTo({ left: scrollWidth, behavior: 'smooth' });
  await new Promise(resolve => setTimeout(resolve, 800));

  // Scroll back to original position
  centerViewport.scrollTo({ left: originalScrollLeft, behavior: 'smooth' });
  await new Promise(resolve => setTimeout(resolve, 800));

  console.log('ensureAllColumnsLoaded: One-time column discovery complete');
  hasLoadedAllColumns = true;

  // Build the col-id to sportsbook name mapping after columns are loaded
  buildSportsbookMapping();

  // Log all discovered columns after loading with cell content preview
  const allColumns = [];
  const containers = ['.ag-pinned-left-cols-container', '.ag-center-cols-container', '.ag-pinned-right-cols-container'];
  containers.forEach((containerSelector, index) => {
    const container = grid.querySelector(containerSelector);
    if (container) {
      const firstRow = container.querySelector('[role="row"]');
      if (firstRow) {
        const cells = firstRow.querySelectorAll('[col-id]');
        cells.forEach(cell => {
          const colId = cell.getAttribute('col-id');
          const cellText = cell.textContent?.trim() || '';
          const cellHTML = cell.innerHTML.substring(0, 100);

          allColumns.push(`${colId} (container ${index})`);

          // Log detailed info for each column
          console.log(`ðŸ” Column: ${colId} | Container: ${index} | Text: "${cellText}" | HTML: ${cellHTML}`);

          // Check if this might be Polymarket based on content
          if (cellText.toLowerCase().includes('polymarket') ||
              cellHTML.toLowerCase().includes('polymarket') ||
              colId.toLowerCase().includes('poly')) {
            console.log(`ðŸŸ¢ POTENTIAL POLYMARKET COLUMN: ${colId} - Content: "${cellText}"`);
          }
        });
      }
    }
  });

  console.log(`ðŸ” All discovered columns after loading: [${allColumns.join(', ')}]`);

  // Check specifically for Polymarket (broader search)
  const polymarketColumns = allColumns.filter(col =>
    col.toLowerCase().includes('polymarket') ||
    col.toLowerCase().includes('poly')
  );
  if (polymarketColumns.length > 0) {
    console.log(`ðŸŸ¢ POLYMARKET COLUMNS FOUND: ${polymarketColumns.join(', ')}`);
  } else {
    console.log(`âš ï¸  NO POLYMARKET COLUMNS FOUND in discovered columns`);
  }
}

// Track discovered sportsbook columns and their names
const discoveredSportsbooks = new Set();
const colIdToSportsbookName = new Map();

// Build mapping from col-id to sportsbook name using header images
function buildSportsbookMapping() {
  const SELECTORS = getSelectors();
  const grid = document.querySelector(SELECTORS.grid.root);
  if (!grid) return;

  console.log('ðŸ—ºï¸ Building col-id to sportsbook name mapping...');

  // Find all header cells
  const headerCells = grid.querySelectorAll('.ag-header-cell[col-id]');
  console.log(`Found ${headerCells.length} header cells with col-id`);

  headerCells.forEach(headerCell => {
    const colId = headerCell.getAttribute('col-id');

    // Look for img with alt attribute in this header cell
    const img = headerCell.querySelector('img[alt]');
    if (img) {
      const sportsbookName = img.getAttribute('alt');
      colIdToSportsbookName.set(colId, sportsbookName);
      console.log(`ðŸ—ºï¸ Mapped: col-id="${colId}" â†’ sportsbook="${sportsbookName}"`);

      // Special alert for Polymarket
      if (sportsbookName.toLowerCase().includes('polymarket')) {
        console.log(`ðŸŸ¢ POLYMARKET MAPPING FOUND: col-id="${colId}" â†’ "${sportsbookName}"`);
      }
    } else {
      // Try to find alt text in any nested image
      const nestedImg = headerCell.querySelector('img');
      if (nestedImg && nestedImg.hasAttribute('alt')) {
        const sportsbookName = nestedImg.getAttribute('alt');
        colIdToSportsbookName.set(colId, sportsbookName);
        console.log(`ðŸ—ºï¸ Mapped (nested): col-id="${colId}" â†’ sportsbook="${sportsbookName}"`);
      }
    }
  });

  console.log(`ðŸ—ºï¸ Mapping complete: ${colIdToSportsbookName.size} sportsbooks mapped`);
  console.log('ðŸ—ºï¸ All mappings:', Array.from(colIdToSportsbookName.entries()));
}

// Monitor for new columns appearing in the DOM
function monitorNewColumns() {
  const SELECTORS = getSelectors();
  const grid = document.querySelector(SELECTORS.grid.root);
  if (!grid) return;

  // Check all containers for new columns
  const containers = [
    grid.querySelector('.ag-pinned-left-cols-container'),
    grid.querySelector('.ag-center-cols-container'),
    grid.querySelector('.ag-pinned-right-cols-container')
  ].filter(Boolean);

  containers.forEach(container => {
    const firstRow = container.querySelector('[role="row"]');
    if (!firstRow) return;

    const cells = firstRow.querySelectorAll('[col-id]');
    cells.forEach(cell => {
      const colId = cell.getAttribute('col-id');

      // Skip non-sportsbook columns
      if (['startTime', 'rotationNumber', 'teamName', 'bestPrice', 'averagePrice'].includes(colId)) {
        return;
      }

      // Check if this is a new sportsbook we haven't seen
      if (!discoveredSportsbooks.has(colId)) {
        discoveredSportsbooks.add(colId);

        // Get sportsbook name from mapping
        const sportsbookName = colIdToSportsbookName.get(colId) || 'Unknown';
        console.log(`ðŸ“Š New sportsbook column discovered: ${colId} (${sportsbookName})`);

        // Enhanced alert for Polymarket using the mapped name
        if (sportsbookName.toLowerCase().includes('polymarket')) {
          const cellText = cell.textContent?.trim() || '';
          const cellHTML = cell.innerHTML;
          console.log(`ðŸŸ¢ POLYMARKET COLUMN NOW AVAILABLE: ${colId} â†’ "${sportsbookName}"`);
          console.log(`ðŸŸ¢ POLYMARKET cell content: "${cellText}"`);
          console.log(`ðŸŸ¢ POLYMARKET cell HTML:`, cellHTML.substring(0, 200));
        }
      }
    });
  });

  return discoveredSportsbooks.size;
}

async function checkAndSendUpdates() {
  console.warn('â›” VISUAL SCRAPING DISABLED - Content script should not be running active scraping');
  console.warn('â›” This system now uses ONLY API scraping via Scrapy unified monitor');
  console.warn('â›” If you see this, visual scraping was incorrectly triggered');

  // Send message to background to log this should not happen
  try {
    await chrome.runtime.sendMessage({
      type: 'VISUAL_SCRAPING_ATTEMPTED',
      url: window.location.href,
      timestamp: Date.now()
    });
  } catch (error) {
    console.error('Could not notify background of visual scraping attempt:', error);
  }

  return; // EXIT IMMEDIATELY - NO VISUAL SCRAPING

  // ========== DISABLED VISUAL SCRAPING CODE BELOW ==========
  // Check if extension context is still valid
  if (extensionInvalidated || !isExtensionContextValid()) {
    console.log('Extension context invalidated - stopping scraper');
    cleanup();
    return;
  }

  console.log('checkAndSendUpdates called');

  // First, check if this URL is active in the database
  try {
    const response = await chrome.runtime.sendMessage({
      type: 'CHECK_URL_ACTIVE',
      url: window.location.href
    });

    if (!response || !response.active) {
      console.log('ðŸ›‘ URL is not active in database - stopping visual scraper');
      return;
    }

    if (response.preferredMethod === 'scrapy') {
      console.log('ðŸ›‘ URL is set to scrapy method - stopping visual scraper');
      return;
    }

    console.log('âœ… URL is active for visual scraping');
  } catch (error) {
    console.error('Error checking URL status:', error);
    // Continue with scraping if database check fails
  }

  // Rebuild mapping in case new columns appeared
  buildSportsbookMapping();

  // Monitor for new columns without scrolling
  const columnCount = monitorNewColumns();
  console.log(`Currently tracking ${columnCount} sportsbook columns`);

  // Choose scraping method based on configuration
  let data = null;

  // Detailed diagnostics for method selection
  console.log('ðŸ” SCRAPING METHOD DIAGNOSTICS:');
  console.log('   Configuration approach:', SCRAPING_CONFIG.approach);
  console.log('   API scraper loaded:', !!apiScraper);
  console.log('   API scraper available:', apiScraper ? apiScraper.isAvailable() : false);
  console.log('   API endpoints discovered:', apiScraper ? apiScraper.endpoints.size : 0);

  if (apiScraper) {
    console.log('   API endpoints details:');
    apiScraper.endpoints.forEach((endpoint, key) => {
      console.log('     -', key, endpoint.path);
    });

    const oddsEndpoints = apiScraper.findOddsEndpoints();
    console.log('   Odds-related endpoints:', oddsEndpoints.length);
    oddsEndpoints.forEach(endpoint => {
      console.log('     - ODDS:', endpoint.method, endpoint.path);
    });
  } else {
    console.log('   âŒ API scraper not loaded - check for errors above');
  }

  if (SCRAPING_CONFIG.approach === 'api' && apiScraper && apiScraper.isAvailable()) {
    console.log('ðŸŽ¯ Using API-based scraping');

    // Update status indicator
    if (window.scrapingStatusIndicator) {
      window.scrapingStatusIndicator.setMethod('API');
      window.scrapingStatusIndicator.setStatus('API polling active');
      window.scrapingStatusIndicator.setApiEndpoints(apiScraper.endpoints.size);
    }

    // API scraper handles its own data sending
    if (!apiScraper.activePolling || apiScraper.activePolling.size === 0) {
      const success = await apiScraper.startAPIScraping();
      if (!success) {
        console.log('âš ï¸ API scraping failed, falling back to visual scraping');
        data = await performVisualScraping();
      } else {
        return; // API scraper will handle data sending
      }
    } else {
      return; // API scraping already active
    }
  } else if (SCRAPING_CONFIG.approach === 'hybrid' && apiScraper && apiScraper.isAvailable()) {
    console.log('ðŸ”„ Using hybrid scraping (API + Visual)');

    // Update status indicator
    if (window.scrapingStatusIndicator) {
      window.scrapingStatusIndicator.setMethod('Hybrid');
      window.scrapingStatusIndicator.setStatus('Hybrid mode active');
      window.scrapingStatusIndicator.setApiEndpoints(apiScraper.endpoints.size);
    }

    // Try API first, fall back to visual if needed
    const apiSuccess = await apiScraper.startAPIScraping();
    if (!apiSuccess) {
      console.log('âš ï¸ API unavailable, using visual scraping');
      data = await performVisualScraping();
    } else {
      return; // API scraper will handle data sending
    }
  } else {
    // Explain why we're using visual scraping
    let reason = 'Configuration set to Visual DOM';
    if (SCRAPING_CONFIG.approach === 'api' || SCRAPING_CONFIG.approach === 'hybrid') {
      if (!apiScraper) {
        reason = 'API scraper failed to load';
      } else if (!apiScraper.isAvailable()) {
        if (apiScraper.endpoints.size === 0) {
          reason = 'No API endpoints discovered on this site';
        } else {
          const oddsEndpoints = apiScraper.findOddsEndpoints();
          if (oddsEndpoints.length === 0) {
            reason = `Found ${apiScraper.endpoints.size} endpoints but none contain odds data`;
          } else {
            reason = 'API endpoints available but scraper reports unavailable';
          }
        }
      }
    }

    console.log('ðŸ‘ï¸ Using visual DOM scraping - Reason:', reason);

    // Update status indicator with diagnostic info
    if (window.scrapingStatusIndicator) {
      window.scrapingStatusIndicator.setMethod('Visual DOM');
      window.scrapingStatusIndicator.setStatus(reason);

      if (SCRAPING_CONFIG.approach === 'api' || SCRAPING_CONFIG.approach === 'hybrid') {
        window.scrapingStatusIndicator.flash(`API unavailable: ${reason}`, 'error');
      }
    }

    data = await performVisualScraping();

    // Update status indicator
    if (window.scrapingStatusIndicator) {
      window.scrapingStatusIndicator.setMethod('Visual DOM');
      window.scrapingStatusIndicator.setStatus(data && data.games.length > 0 ?
        `Found ${data.games.length} games` : 'No games found');
      window.scrapingStatusIndicator.setApiEndpoints(0);
    }
  }

  if (!data || data.games.length === 0) {
    console.log('No data scraped or no games found');
    return;
  }

  console.log('Scraped data:', data.games.length, 'games');

  // Log details about first game to see what odds we have
  if (data.games.length > 0) {
    const firstGame = data.games[0];
    console.log('First game details:', {
      teams: `${firstGame.homeTeam} vs ${firstGame.awayTeam}`,
      sport: firstGame.sport,
      betType: firstGame.betType,
      oddsCount: Object.keys(firstGame.odds).length,
      odds: firstGame.odds,
      bestOdds: `${firstGame.bestHomeOdds}/${firstGame.bestAwayOdds}`,
      avgOdds: `${firstGame.avgHomeOdds}/${firstGame.avgAwayOdds}`
    });
  }

  const currentHash = generateDataHash(data);

  if (currentHash !== lastDataHash || lastDataHash === null) {
    const isForced = lastDataHash === null;
    console.log(`${isForced ? 'ðŸ”„ FORCED' : 'ðŸ“Š DATA CHANGED'}: Sending update with ${data.games.length} games`);
    if (isForced) {
      console.log('ðŸ“¡ Full refresh - sending all data regardless of changes');
    }
    lastDataHash = currentHash;
    sendData(data);
  } else {
    console.log('ðŸ“‹ Data unchanged - using cached version');
  }
}

// Set up mutation observer for dynamic content
function setupObserver() {
  if (observer) observer.disconnect();

  const SELECTORS = getSelectors();
  const grid = document.querySelector(SELECTORS.grid.root);
  if (!grid) {
    // Try again in a second
    setTimeout(setupObserver, 1000);
    return;
  }

  observer = new MutationObserver((mutations) => {
    // Debounce updates
    clearTimeout(observer.debounceTimer);
    observer.debounceTimer = setTimeout(async () => {
      await checkAndSendUpdates();
    }, 500);
  });

  observer.observe(grid, {
    childList: true,
    subtree: true,
    attributes: true,
    attributeFilter: ['col-id', 'row-id']
  });

  console.log('Observer set up successfully');
}

// Initialize scraping
async function initialize() {
  console.log('Initializing sportsbook scraper');
  console.log('Current URL:', window.location.href);
  console.log('Page title:', document.title);

  // Load league mappings first
  await loadLeagueMappings();

  // Set up observer
  setupObserver();

  // Initial scrape
  setTimeout(async () => {
    console.log('Running initial scrape...');
    await checkAndSendUpdates();
  }, 2000);

  // Set up periodic checks
  if (scrapeInterval) clearInterval(scrapeInterval);
  scrapeInterval = setInterval(async () => {
    await checkAndSendUpdates();
  }, 5000);

  // Set up forced full refresh every 5 minutes to ensure we don't miss data
  if (fullRefreshInterval) clearInterval(fullRefreshInterval);
  fullRefreshInterval = setInterval(async () => {
    console.log('ðŸ”„ FORCED FULL REFRESH: Clearing cache and forcing complete data resend');
    lastDataHash = null; // Clear cache to force sending data even if unchanged
    await checkAndSendUpdates();
  }, 5 * 60 * 1000); // 5 minutes
}

// Cleanup function for extension invalidation
function cleanup() {
  console.log('Cleaning up scraper resources');
  extensionInvalidated = true;

  if (observer) {
    observer.disconnect();
    observer = null;
  }

  if (scrapeInterval) {
    clearInterval(scrapeInterval);
    scrapeInterval = null;
  }

  if (fullRefreshInterval) {
    clearInterval(fullRefreshInterval);
    fullRefreshInterval = null;
  }
}

// Clean up on page unload
window.addEventListener('beforeunload', cleanup);

// Check if we're on a sportsbook page
function initializeIfApplicable() {
  // Check if extension context is valid before initializing
  if (!isExtensionContextValid()) {
    console.log('Extension context invalid - not initializing scraper');
    return;
  }

  // Detect layout first
  const layout = detectLayout();
  const SELECTORS = getSelectors();

  if (window.location.href.includes('odds') || document.querySelector(SELECTORS.grid.root)) {
    console.log(`Initializing scraper with layout: ${layout.name}`);
    initialize();
  } else {
    console.log('Not a sportsbook page, scraper not initialized');
  }
}

// Message listener for popup controls
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (extensionInvalidated) {
    sendResponse({ success: false, error: 'Extension invalidated' });
    return;
  }

  try {
    if (request.type === 'START_SCRAPING') {
      console.log('Starting scraping via popup control');
      if (!scrapeInterval) {
        initialize();
      }
      sendResponse({ success: true });
    } else if (request.type === 'STOP_SCRAPING') {
      console.log('Stopping scraping via popup control');
      cleanup();
      sendResponse({ success: true });
    } else if (request.type === 'CHECK_API_STATUS') {
      // Return API scraper status for diagnostics
      sendResponse({
        success: true,
        apiScraperLoaded: !!apiScraper,
        apiScraperAvailable: apiScraper ? apiScraper.isAvailable() : false,
        endpointsCount: apiScraper ? apiScraper.endpoints.size : 0,
        configApproach: SCRAPING_CONFIG.approach
      });
    }
  } catch (error) {
    console.error('Error handling message:', error);
    sendResponse({ success: false, error: error.message });
  }
});

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeIfApplicable);
} else {
  initializeIfApplicable();
}

// Global debug function for browser console access
window.debugAllColumns = function() {
  console.log('ðŸ”§ MANUAL COLUMN DEBUG - Starting comprehensive inspection...');

  const grid = document.querySelector('.ag-root, div.ag-root');
  if (!grid) {
    console.log('âŒ No AG Grid found');
    return;
  }

  console.log('âœ… AG Grid found:', grid);

  // First, build the sportsbook mapping
  if (typeof buildSportsbookMapping === 'function') {
    console.log('ðŸ—ºï¸ Building sportsbook mapping...');
    // Call the function from the extension scope if available
    try {
      buildSportsbookMapping();
    } catch (e) {
      console.log('Could not call buildSportsbookMapping from debug function');
    }
  }

  // Show current mapping if available
  if (typeof colIdToSportsbookName !== 'undefined' && colIdToSportsbookName.size > 0) {
    console.log('ðŸ—ºï¸ Current col-id to sportsbook mapping:');
    Array.from(colIdToSportsbookName.entries()).forEach(([colId, name]) => {
      console.log(`  ${colId} â†’ ${name}`);
      if (name.toLowerCase().includes('polymarket')) {
        console.log(`    ðŸŸ¢ *** POLYMARKET FOUND IN MAPPING ***`);
      }
    });
  }

  // Check all possible containers
  const containerSelectors = [
    '.ag-pinned-left-cols-container',
    '.ag-center-cols-container',
    '.ag-pinned-right-cols-container',
    '.ag-body-viewport',
    '.ag-center-cols-viewport'
  ];

  containerSelectors.forEach((selector, index) => {
    const container = grid.querySelector(selector);
    if (container) {
      console.log(`ðŸ“¦ Container ${index} (${selector}):`, container);

      // Get all rows
      const rows = container.querySelectorAll('[role="row"]');
      console.log(`  Found ${rows.length} rows`);

      if (rows.length > 0) {
        const firstRow = rows[0];
        const cells = firstRow.querySelectorAll('[col-id]');
        console.log(`  Found ${cells.length} cells with col-id in first row`);

        cells.forEach((cell, cellIndex) => {
          const colId = cell.getAttribute('col-id');
          const text = cell.textContent?.trim() || '';
          const html = cell.innerHTML.substring(0, 150);

          console.log(`    Cell ${cellIndex}: col-id="${colId}" | text="${text}" | html=${html}`);

          // Check for Polymarket indicators
          const isPolymarket = colId.toLowerCase().includes('polymarket') ||
                              colId.toLowerCase().includes('poly') ||
                              text.toLowerCase().includes('polymarket') ||
                              html.toLowerCase().includes('polymarket');

          if (isPolymarket) {
            console.log(`    ðŸŸ¢ *** POLYMARKET DETECTED IN CELL ${cellIndex} ***`);
          }
        });
      }
    } else {
      console.log(`âŒ Container ${index} (${selector}) not found`);
    }
  });

  // Also check for any elements containing "polymarket" anywhere
  const allPolyElements = document.querySelectorAll('*');
  let polyCount = 0;
  Array.from(allPolyElements).forEach(el => {
    if (el.textContent?.toLowerCase().includes('polymarket') ||
        el.innerHTML?.toLowerCase().includes('polymarket') ||
        el.getAttribute('col-id')?.toLowerCase().includes('poly')) {
      polyCount++;
      if (polyCount <= 5) { // Only log first 5 to avoid spam
        console.log(`ðŸ” Element containing 'polymarket':`, el, 'Text:', el.textContent?.substring(0, 100));
      }
    }
  });
  console.log(`ðŸ” Found ${polyCount} elements containing 'polymarket'`);

  console.log('ðŸ”§ Manual column debug complete');
};

console.log('ðŸ”§ Debug function available: Run window.debugAllColumns() in console to inspect all columns');

})(); // End of IIFE
â›” This system now uses ONLY API scraping via Scrapy unified monitor
â›” If you see this, visual scraping was incorrectly triggered
